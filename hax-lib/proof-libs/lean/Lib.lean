-- This library is the panic-free version of the prelude, where identifiers are
-- *as most as possible* interpreted without any proof obligation, ignoring
-- potential rust panics. It is useful for testing, but proving properties with
-- it would not guarantee panic freedom.

-- Logic
abbrev hax_logical_op_and := (fun a b => a ∧ b)

-- Integer types
abbrev u8 := Nat -- to fix
abbrev u16 := UInt16
abbrev u32 := UInt32
abbrev u64 := UInt64
abbrev usize := USize
abbrev i8 := Int -- to fix
abbrev i16 := Int16
abbrev i32 := Int32
abbrev i64 := Int64
abbrev isize := ISize

-- Coercions between integers types:
instance : Coe i32 i64 where
  coe x := x.toInt64

instance : Coe i64 i32 where
  coe x := x.toInt32

-- Arithmetic
@[simp]
def hax_machine_int_add {α} [Add α] (x y: α) := x + y
@[simp]
def hax_machine_int_sub {α} [Sub α] (x y: α) := x - y
@[simp]
def hax_machine_int_mul {α} [Mul α] (x y: α) := x * y
@[simp]
def hax_machine_int_rem {α} [Mod α] (x y: α) := x % y
@[simp]
def hax_machine_int_shr {α β γ} [HShiftRight α β γ] (a: α) (b: β) : γ := a >>> b
@[simp]
def ops_arith_Neg_neg {α} [Neg α] (x:α) := -x

@[simp]
def hax_machine_int_eq {α} (x y: α) [BEq α] : Bool := x == y
@[simp]
def hax_machine_int_ne (x y: Int) : Bool := x != y
@[simp]
def hax_machine_int_lt {α} (x y: α) [(LT α)] [Decidable (x < y)] : Bool := x < y
@[simp]
def hax_machine_int_le {α} (x y: α) [(LE α)] [Decidable (x ≤ y)] : Bool := x ≤ y
@[simp]
def hax_machine_int_gt {α} (x y: α) [(LE α)] [Decidable (x ≥ y)] : Bool := x ≥ y
@[simp]
def hax_machine_int_ge {α} (x y: α) [(LT α)] [Decidable (x > y)] : Bool := x > y

-- Tuples
structure hax_Tuple2_arg α β where
hax_Tuple2_Tuple0 : α
hax_Tuple2_Tuple1 : β

inductive hax_Tuple2 (α β: Type)
| constr_hax_Tuple2 : (hax_Tuple2_arg α β) -> hax_Tuple2 α β

abbrev hax_Tuple0 := ()

-- Nums
def num_impl_wrapping_add : Nat -> Nat -> Nat := sorry
def num_impl_from_le_bytes {α} : (Array α) -> u32 := sorry

-- Casts
@[simp]
def convert_From_from {α β} [Coe α β] (x:α) : β := x
@[simp]
def hax_cast_op {α β} [Coe α β] (x:α) : β := x

-- Results
inductive result_Result α β
| ok : α -> result_Result α β
| err : β -> result_Result α β

axiom array_TryFromSliceError : Type

-- Assert
def assert : Bool -> Unit := fun _ => ()
def assume : Prop -> Unit := fun _ => ()
def prop_constructors_from_bool : Bool -> Prop := sorry

-- Hax
def hax_folds_fold_range
  (s: Nat)
  (e: Nat) :
  ((Array u32) -> Nat -> Bool) ->
  (Array u32) ->
  ((Array u32) -> Nat -> (Array u32)) ->
  (Array u32) := sorry

def hax_monomorphized_update_at_update_at_usize :
  (Array u32) ->
  Nat ->
  u32 ->
  (Array u32) := sorry

abbrev hax__autogenerated_refinement__BoundedUsize_BoundedUsize (_: Nat) (_: Nat) := Nat

def result_impl_unwrap {α} : α -> Array β := sorry

-- Vectors
def hax_repeat (x:Nat) (y:Nat) : Array u32 := sorry

-- Ranges

structure ops_range_Range_arg (α: Type) where
ops_range_Range_start : α
ops_range_Range_end : α

inductive ops_range_Range (α: Type)  where
| constr_ops_range_Range : ops_range_Range_arg α -> ops_range_Range α


-- Arrays
def ops_index_Index_index (a: Array u8) : α -> β := sorry
def convert_TryInto_try_into {α} : Array α ->
   result_Result (Array α) array_TryFromSliceError := sorry


-- Slices
def slice_impl_len (a: Array u32) : Nat := sorry

-- Bytes
def num_impl_to_le_bytes : u32 -> Array u8 := sorry
