-- This library is the panic-free version of the prelude, where identifiers are
-- *as most as possible* interpreted without any proof obligation, ignoring
-- potential rust panics. It is useful for testing, but proving properties with
-- it would not guarantee panic freedom.

-- Aeneas errors

inductive Error where
   | assertionFailure: Error
   | integerOverflow: Error
   | divisionByZero: Error
   | arrayOutOfBounds: Error
   | maximumSizeExceeded: Error
   | panic: Error
   | undef: Error
deriving Repr, BEq

open Error

inductive Result.{u} (α : Type u) where
  | ok (v: α): Result α
  | fail (e: Error): Result α
  | div
deriving Repr, BEq

instance : Monad Result where
  pure x := .ok x
  bind x f := match x with
  | .ok v => f v
  | .fail e => .fail e
  | .div => .div

instance : LawfulMonad Result := sorry

-- Logic
abbrev hax_logical_op_and := (fun a b => a ∧ b)

-- Integer types
abbrev u8 := Nat -- to fix
abbrev i8 := Int -- to fix

abbrev u16 := UInt16
abbrev u32 := UInt32
abbrev u64 := UInt64
abbrev usize := USize
abbrev i16 := Int16
abbrev i32 := Int32
abbrev i64 := Int64
abbrev isize := ISize

-- Coercions between integers types:
instance : Coe i32 i64 where
  coe x := x.toInt64

instance : Coe i64 i32 where
  coe x := x.toInt32

instance : Coe USize Nat where
  coe x := x.toNat

instance : Coe (BitVec 32) u32 where
  coe x := UInt32.ofBitVec x

instance {n} : CoeOut (BitVec n) (Result u32) where
  coe x := match n with
  | 32 => .ok (UInt32.ofBitVec x)
  | _ => .fail (integerOverflow)

instance : Coe u32 (BitVec 32) where
  coe x := x.toBitVec

instance : Coe u32 Nat where
  coe x := x.toNat

-- Arithmetic
section Arithmetic

-- Overflowing operations
@[simp]
def hax_machine_int_add {α} [Add α] (x y: α) := x + y
@[simp]
def hax_machine_int_sub {α} [Sub α] (x y: α) := x - y
@[simp]
def hax_machine_int_mul {α} [Mul α] (x y: α) := x * y
@[simp]
def hax_machine_int_rem {α} [Mod α] (x y: α) := x % y
@[simp]
def hax_machine_int_shr {α β γ} [HShiftRight α β γ] (a: α) (b: β) : γ := a >>> b
@[simp]
def hax_machine_int_bitxor {α} [Xor α] (a b: α) : α := a ^^^ b
@[simp]
def ops_arith_Neg_neg {α} [Neg α] (x:α) := -x

@[simp]
def hax_machine_int_eq {α} (x y: α) [BEq α] : Bool := x == y
@[simp]
def hax_machine_int_ne {α} (x y: α) [BEq α] : Bool := x != y
@[simp]
def hax_machine_int_lt {α} (x y: α) [(LT α)] [Decidable (x < y)] : Bool := x < y
@[simp]
def hax_machine_int_le {α} (x y: α) [(LE α)] [Decidable (x ≤ y)] : Bool := x ≤ y
@[simp]
def hax_machine_int_gt {α} (x y: α) [(LE α)] [Decidable (x ≥ y)] : Bool := x ≥ y
@[simp]
def hax_machine_int_ge {α} (x y: α) [(LT α)] [Decidable (x > y)] : Bool := x > y

abbrev hax__autogenerated_refinement__BoundedUsize_BoundedUsize
  (lo: USize) (hi: USize) := USize
--  {u : usize // lo ≤ u ∧ u ≤ hi}

-- #check hax__autogenerated_refinement__BoundedUsize_BoundedUsize 0 19
-- #check fun (x: {usize // True}) => x.val

set_option pp.coercions false

-- instance {n lo hi : Nat} {hlo: lo ≤ x} {hhi: x ≤ hi}:
--   OfNat (hax__autogenerated_refinement__BoundedUsize_BoundedUsize lo hi) x where
--   ofNat := {
--     val := x ,
--     property := by
--       constructor
--       . unfold Nat.cast

--         apply USize.le_iff_toNat_le.mp

--       . apply USize.le_iff_toNat_le.mp
--         grind

--   }
-- #check (10: hax__autogenerated_refinement__BoundedUsize_BoundedUsize 0 10)

-- Wrapping operations
@[simp]
def num_impl_wrapping_add {α} [Add α] (x y: α) := x + y

@[simp]
def num_impl_rotate_left {w} := @BitVec.rotateLeft w

end Arithmetic

-- Tuples
structure hax_Tuple2_arg (α β: Type) where
hax_Tuple2_Tuple0 : α
hax_Tuple2_Tuple1 : β

inductive hax_Tuple2 (α β: Type)
| constr_hax_Tuple2 : (hax_Tuple2_arg α β) -> hax_Tuple2 α β

abbrev hax_Tuple0 := ()

-- Nums
def num_impl_from_le_bytes {α} : (Array α) -> u32 := sorry

-- Casts
@[simp]
def convert_From_from {α β} [Coe α β] (x:α) : β := x
@[simp]
def hax_cast_op {α β} [Coe α β] (x:α) : β := x

-- Results
inductive result_Result α β
| ok : α -> result_Result α β
| err : β -> result_Result α β

axiom array_TryFromSliceError : Type

-- Assert
def assert (b:Bool) : Result Unit :=
  if b then pure ()
  else .fail (Error.assertionFailure)

def assume : Prop -> Unit := fun _ => ()
def prop_constructors_from_bool : Bool -> Prop := sorry

-- Hax
def hax_folds_fold_range {α}
  (s e : Nat)
  (_filter : α -> Nat -> Bool)
  (init: α)
  (f : α -> Nat -> Result α) :=
  Array.foldlM f init (Array.range e) s e

-- Arrays

def hax_monomorphized_update_at_update_at_usize {α}
  (a: Array α) (i:Nat) (v:α) : Result (Array α) :=
  if h: i < a.size then
    pure ( Array.set a i v )
  else
    .fail (.arrayOutOfBounds)

def hax_update_at {α n} (m : Vector α n) (i : Nat) (v : α) : Result (Vector α n) :=
  if i < n then
    .ok ( Vector.setIfInBounds m i v)
  else
    .fail (.arrayOutOfBounds)


def result_impl_unwrap {α} : α -> Array β := sorry

-- Vectors
def hax_repeat (x:Nat) (y:Nat) : Array u32 := sorry

-- Ranges

structure ops_range_Range_arg (α: Type) where
ops_range_Range_start : α
ops_range_Range_end : α

inductive ops_range_Range (α: Type)  where
| constr_ops_range_Range : ops_range_Range_arg α -> ops_range_Range α



-- Arrays
section Arrays
def ops_index_Index_index (a: Array α) (i:Nat) : Result α :=
  match a[i]? with
  | .none => .fail arrayOutOfBounds
  | .some v => .ok v

def convert_TryInto_try_into {α} : Array α ->
   result_Result (Array α) array_TryFromSliceError := sorry

instance {α n} : CoeOut (Vector α n) (Array α) where
  coe x := x.toArray

instance {α β} [i:Coe α β]: Coe (Array α) (Array β) where
  coe x := Array.map i.coe x

end Arrays
-- Slices
def slice_impl_len (a: Array u32) : Nat := sorry

-- Bytes
def num_impl_to_le_bytes : u32 -> Array u8 := sorry
