(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.

(* From Core Require Import Core. *)

(* TODO: Replace this dummy lib with core lib *)
Class t_Sized (T : Type) := { }.
Definition t_u8 := Z.
Definition t_u16 := Z.
Definition t_u32 := Z.
Definition t_u64 := Z.
Definition t_u128 := Z.
Definition t_usize := Z.
Definition t_i8 := Z.
Definition t_i16 := Z.
Definition t_i32 := Z.
Definition t_i64 := Z.
Definition t_i128 := Z.
Definition t_isize := Z.
Definition t_Array T (x : t_usize) := list T.
Definition t_String := string.
Definition ToString_f_to_string (x : string) := x.
Instance Sized_any : forall {t_A}, t_Sized t_A := {}.
Class t_Clone (T : Type) := { Clone_f_clone : T -> T }.
Instance Clone_any : forall {t_A}, t_Clone t_A := {Clone_f_clone := fun x => x}.
Definition t_Slice (T : Type) := list T.
Definition unsize {T : Type} : list T -> t_Slice T := id.
Definition t_PartialEq_f_eq x y := x =? y.
Definition t_Rem_f_rem (x y : Z) := x mod y.
Definition assert (b : bool) (* `{H_assert : b = true} *) : unit := tt.
Inductive globality := | t_Global.
Definition t_Vec T (_ : globality) : Type := list T.
Definition impl_1__append {T} l1 l2 : list T * list T := (app l1 l2, l2).
Definition impl_1__len {A} (l : list A) := Z.of_nat (List.length l).
Definition impl__new {A} (_ : Datatypes.unit) : list A := nil.
Definition impl__with_capacity {A} (_ : Z)  : list A := nil.
Definition impl_1__push {A} l (x : A) := cons x l.
Class t_From (A B : Type) := { From_f_from : B -> A }.
Definition impl__to_vec {T} (x : t_Slice T) : t_Vec T t_Global := x.
Class t_Into (A B : Type) := { Into_f_into : A -> B }.
Instance t_Into_from_t_From {A B : Type} `{H : t_From B A} : t_Into A B := { Into_f_into x := @From_f_from B A H x }.
Definition from_elem {A} (x : A) (l : Z) := repeat x (Z.to_nat l).
Definition t_Option := option.
Definition impl__map {A B} (x : t_Option A) (f : A -> B) : t_Option B := match x with | Some x => Some (f x) | None => None end.
Definition t_Add_f_add x y := x + y.
Class Cast A B := { cast : A -> B }.
Instance cast_t_u8_t_u32 : Cast t_u8 t_u32 := {| cast x := x |}.
(* / dummy lib *)

From Core Require Import Core_Base_Spec.
Export Core_Base_Spec.

From Core Require Import Core_Base_Haxint_lt.
Export Core_Base_Haxint_lt.

From Core Require Import Core_Clone (t_Clone).
Export Core_Clone (t_Clone).

From Core Require Import Core (t_cmp).
Export Core (t_cmp).

From Core Require Import Core_Marker (t_Sized).
Export Core_Marker (t_Sized).

From Core Require Import Core (t_panicking).
Export Core (t_panicking).

Definition hd__panic_cold_explicit '(_ : unit) : t_Never :=
  panic_explicit (tt).

Definition set_index__set_index_unary__panic_cold_explicit '(_ : unit) : t_Never :=
  panic_explicit (tt).

Definition is_empty `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (s : t_Seq ((v_T))) : bool :=
  match match_list (s) with
  | LIST_NIL =>
    true
  | LIST_CONS (_) (_) =>
    false
  end.

Definition hd `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (s : t_Seq ((v_T))) `{negb (is_empty (s)) = true} : v_T :=
  match match_list (s) with
  | LIST_NIL =>
    never_to_any (hd__panic_cold_explicit (tt))
  | LIST_CONS (hd) (_) =>
    hd
  end.

Definition tl `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (s : t_Seq ((v_T))) `{negb (is_empty (s)) = true} : t_Seq ((v_T)) :=
  match match_list (s) with
  | LIST_NIL =>
    nil (tt)
  | LIST_CONS (_) (tl) =>
    tl
  end.

Fixpoint eq_inner `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} `{t_PartialEq (v_T) (v_T)} (s : t_Seq ((v_T))) (other : t_Seq ((v_T))) : bool :=
  match match_list (Clone_f_clone (s)) with
  | LIST_NIL =>
    is_empty (Clone_f_clone (other))
  | LIST_CONS (x) (xs) =>
    match match_list (Clone_f_clone (other)) with
    | LIST_NIL =>
      false
    | LIST_CONS (y) (ys) =>
      andb (PartialEq_f_eq (x) (y)) (eq_inner (xs) (ys))
    end
  end.

Instance t_PartialEq_126322860 `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} `{t_PartialEq (v_T) (v_T)} : t_PartialEq ((t_Seq ((v_T)))) ((t_Seq ((v_T)))) :=
  {
    PartialEq_impl_f_eq := fun  (self : t_Seq ((v_T))) (other : t_Seq ((v_T)))=>
      eq_inner (Clone_f_clone (self)) (Clone_f_clone (other));
    PartialEq_impl_f_ne := fun  (self : t_Seq ((v_T))) (other : t_Seq ((v_T)))=>
      negb (eq_inner (Clone_f_clone (self)) (Clone_f_clone (other)));
  }.

Fixpoint get_index__get_index_unary `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (l : t_Seq ((v_T))) (i : t_Unary) : v_T :=
  match match_unary (i) with
  | UNARY_ZERO =>
    hd (l)
  | UNARY_SUCC (n) =>
    get_index__get_index_unary (tl (l)) (n)
  end.

Definition get_index `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (s : t_Seq ((v_T))) (i : t_HaxInt) : v_T :=
  get_index__get_index_unary (s) (unary_from_int (i)).

Fixpoint len `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (s : t_Seq ((v_T))) : t_HaxInt :=
  match match_list (s) with
  | LIST_NIL =>
    v_HaxInt_ZERO
  | LIST_CONS (_) (tl) =>
    succ (len (tl))
  end.

Fixpoint repeat__repeat_unary `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (n : t_Unary) (v : v_T) : t_Seq ((v_T)) :=
  match match_unary (n) with
  | UNARY_ZERO =>
    nil (tt)
  | UNARY_SUCC (m) =>
    cons (repeat__repeat_unary (m) (Clone_f_clone (v))) (v)
  end.

Definition repeat `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (n : t_HaxInt) (v : v_T) : t_Seq ((v_T)) :=
  repeat__repeat_unary (unary_from_int (n)) (v).

Fixpoint rev__rev_accum `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (s : t_Seq ((v_T))) (accum : t_Seq ((v_T))) : t_Seq ((v_T)) :=
  match match_list (s) with
  | LIST_NIL =>
    accum
  | LIST_CONS (hd) (tl) =>
    rev__rev_accum (tl) (cons (accum) (hd))
  end.

Definition rev `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (s : t_Seq ((v_T))) : t_Seq ((v_T)) :=
  rev__rev_accum (s) (nil (tt)).

Fixpoint set_index__set_index_unary `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (x : t_Seq ((v_T))) (i : t_Unary) (v : v_T) : t_Seq ((v_T)) :=
  match match_list (x) with
  | LIST_NIL =>
    never_to_any (set_index__set_index_unary__panic_cold_explicit (tt))
  | LIST_CONS (hd) (tl) =>
    match match_unary (i) with
    | UNARY_ZERO =>
      cons (tl) (v)
    | UNARY_SUCC (n) =>
      cons (set_index__set_index_unary (tl) (n) (v)) (hd)
    end
  end.

Definition set_index `{v_T : Type} `{t_Sized (v_T)} `{t_Clone (v_T)} (s : t_Seq ((v_T))) (i : t_HaxInt) (v : v_T) `{haxint_lt (i) (len (s)) = true} : t_Seq ((v_T)) :=
  set_index__set_index_unary (s) (unary_from_int (i)) (v).
