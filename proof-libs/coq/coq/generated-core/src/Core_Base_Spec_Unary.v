(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Require Import Super_Haxint.
Export Super_Haxint.

Record t_Unary : Type := {
  0 : t_HaxInt_t;
}.

#[global] Instance t_Unary_t_t_Clone : t_Clone t_Unary_t := {
  f_clone (self : t_Unary_t) := never_to_any (panic_fmt (impl_2__new_v1 (array_from_list [not yet implemented: specification needed]) (impl_1__none tt)));
}.

Inductive t_UNARY : Type :=
| UNARY_ZERO : t_UNARY
| UNARY_SUCC : t_Unary_t -> t_UNARY.

Definition pred (x : t_Unary_t) : t_Unary_t :=
  never_to_any (panic_fmt (impl_2__new_v1 (array_from_list [not yet implemented: specification needed]) (impl_1__none tt))).

Definition succ (x : t_Unary_t) : t_Unary_t :=
  never_to_any (panic_fmt (impl_2__new_v1 (array_from_list [not yet implemented: specification needed]) (impl_1__none tt))).

Definition unary_from_int (x : t_HaxInt_t) : t_Unary_t :=
  Unary x.

Definition unary_to_int (s : t_Unary_t) : t_HaxInt_t :=
  0 s.

Definition match_unary (s : t_Unary_t) : t_UNARY_t :=
  if is_zero (unary_to_int (f_clone s))
  then UNARY_ZEROt_UNARY_t
  else UNARY_SUCC (pred s).
