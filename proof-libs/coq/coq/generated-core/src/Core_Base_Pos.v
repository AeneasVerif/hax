(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

Require Import Super_Spec.
Export Super_Spec.

Require Import Super_Binary.
Export Super_Binary.

Require Import Ordering.
Export Ordering.

Definition haxint_shr__half (s : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos s with
  | POS_ZERO  =>
    v_HaxInt_ZERO
  | POS_POS n =>
    match match_positive n with
    | POSITIVE_XH  =>
      v_HaxInt_ZERO
    | POSITIVE_XO p =>
      positive_to_int p
    | POSITIVE_XI p =>
      positive_to_int p
    end
  end.

Definition haxint_sub__succ_double_mask (lhs : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    positive_to_int xH
  | POS_POS p =>
    positive_to_int (xI p)
  end.

Definition haxint_succ_double (s : t_HaxInt_t) : t_Positive_t :=
  match match_pos s with
  | POS_ZERO  =>
    xH
  | POS_POS p =>
    xI p
  end.

Definition haxint_double (s : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos s with
  | POS_ZERO  =>
    v_HaxInt_ZERO
  | POS_POS p =>
    positive_to_int (xO p)
  end.

Definition haxint_sub__double_mask (lhs : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    v_HaxInt_ZERO
  | POS_POS p =>
    positive_to_int (xO p)
  end.

Definition bitand_binary (lhs : t_Positive_t) (rhs : t_Positive_t) : t_HaxInt_t :=
  match match_positive lhs with
  | POSITIVE_XH  =>
    match match_positive rhs with
    | POSITIVE_XO q =>
      v_HaxInt_ZERO
    | POSITIVE_XI _ | POSITIVE_XH  =>
      v_HaxInt_ONE
    end
  | POSITIVE_XO p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      v_HaxInt_ZERO
    | POSITIVE_XO q | POSITIVE_XI q =>
      haxint_double (bitand_binary p q)
    end
  | POSITIVE_XI p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      v_HaxInt_ONE
    | POSITIVE_XO q =>
      haxint_double (bitand_binary p q)
    | POSITIVE_XI q =>
      positive_to_int (haxint_succ_double (bitand_binary p q))
    end
  end.

Definition bitor_binary (lhs : t_Positive_t) (rhs : t_Positive_t) : t_Positive_t :=
  match match_positive lhs with
  | POSITIVE_XH  =>
    match match_positive rhs with
    | POSITIVE_XO q =>
      xI q
    | POSITIVE_XH  =>
      xH
    | POSITIVE_XI q =>
      xI q
    end
  | POSITIVE_XO p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      xI p
    | POSITIVE_XO q =>
      xO (bitor_binary p q)
    | POSITIVE_XI q =>
      xI (bitor_binary p q)
    end
  | POSITIVE_XI p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      xI p
    | POSITIVE_XO q | POSITIVE_XI q =>
      xI (bitor_binary p q)
    end
  end.

Definition haxint_bitand (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    v_HaxInt_ZERO
  | POS_POS p =>
    match match_pos rhs with
    | POS_ZERO  =>
      v_HaxInt_ZERO
    | POS_POS q =>
      bitand_binary p q
    end
  end.

Definition haxint_bitor (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    rhs
  | POS_POS p =>
    match match_pos rhs with
    | POS_ZERO  =>
      positive_to_int p
    | POS_POS q =>
      positive_to_int (bitor_binary p q)
    end
  end.

Definition haxint_bitxor__bitxor_binary (lhs : t_Positive_t) (rhs : t_Positive_t) : t_HaxInt_t :=
  match match_positive lhs with
  | POSITIVE_XH  =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      v_HaxInt_ZERO
    | POSITIVE_XO q =>
      positive_to_int (xI q)
    | POSITIVE_XI q =>
      positive_to_int (xO q)
    end
  | POSITIVE_XO p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      positive_to_int (xI p)
    | POSITIVE_XO q =>
      haxint_double (haxint_bitxor__bitxor_binary p q)
    | POSITIVE_XI q =>
      positive_to_int (haxint_succ_double (haxint_bitxor__bitxor_binary p q))
    end
  | POSITIVE_XI p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      positive_to_int (xO p)
    | POSITIVE_XO q =>
      positive_to_int (haxint_succ_double (haxint_bitxor__bitxor_binary p q))
    | POSITIVE_XI q =>
      haxint_double (haxint_bitxor__bitxor_binary p q)
    end
  end.

Definition haxint_bitxor (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    rhs
  | POS_POS p =>
    match match_pos rhs with
    | POS_ZERO  =>
      positive_to_int p
    | POS_POS q =>
      haxint_bitxor__bitxor_binary p q
    end
  end.

Definition haxint_cmp (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_Ordering_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    match match_pos rhs with
    | POS_ZERO  =>
      Ordering_Equalt_Ordering_t
    | POS_POS q =>
      Ordering_Lesst_Ordering_t
    end
  | POS_POS p =>
    match match_pos rhs with
    | POS_ZERO  =>
      Ordering_Greatert_Ordering_t
    | POS_POS q =>
      positive_cmp p q
    end
  end.

Definition haxint_le (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : bool :=
  match Option_Some (haxint_cmp lhs rhs) with
  | Option_Some Ordering_Less  | Ordering_Equal  =>
    true
  | _ =>
    false
  end.

Definition haxint_lt (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : bool :=
  match Option_Some (haxint_cmp lhs rhs) with
  | Option_Some Ordering_Less  =>
    true
  | _ =>
    false
  end.

Definition haxint_shl__shl_helper (rhs : t_Unary_t) (lhs : t_HaxInt_t) : t_HaxInt_t :=
  if is_zero (f_clone lhs)
  then lhs
  else match match_unary rhs with
    | UNARY_ZERO  =>
      lhs
    | UNARY_SUCC n =>
      haxint_shl__shl_helper n (haxint_double lhs)
    end.

Definition haxint_shl (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  haxint_shl__shl_helper (unary_from_int rhs) lhs.

Definition haxint_shr__shr_helper (rhs : t_Unary_t) (lhs : t_HaxInt_t) : t_HaxInt_t :=
  if is_zero (f_clone lhs)
  then lhs
  else match match_unary rhs with
    | UNARY_ZERO  =>
      lhs
    | UNARY_SUCC n =>
      haxint_shr__shr_helper n (haxint_shr__half lhs)
    end.

Definition haxint_shr (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  haxint_shr__shr_helper (unary_from_int rhs) lhs.

Definition haxint_sub__double_pred_mask (lhs : t_Positive_t) : t_HaxInt_t :=
  match match_positive lhs with
  | POSITIVE_XH  =>
    v_HaxInt_ZERO
  | POSITIVE_XO p =>
    positive_to_int (xO (positive_pred_double p))
  | POSITIVE_XI p =>
    positive_to_int (xO (xO p))
  end.

Definition power_of_two (s : t_Unary_t) : t_Positive_t :=
  match match_unary s with
  | UNARY_ZERO  =>
    xH
  | UNARY_SUCC x =>
    xO (power_of_two x)
  end.

Definition haxint_add (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    rhs
  | POS_POS p =>
    match match_pos rhs with
    | POS_ZERO  =>
      positive_to_int p
    | POS_POS q =>
      positive_to_int (positive_add p q)
    end
  end.

Definition haxint_sub (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    v_HaxInt_ZERO
  | POS_POS p =>
    match match_pos rhs with
    | POS_ZERO  =>
      positive_to_int p
    | POS_POS q =>
      haxint_sub__sub_binary p q
    end
  end.

Definition haxint_divmod__divmod_binary (a : t_Positive_t) (b : t_Positive_t) : t_HaxInt_t × t_HaxInt_t :=
  match match_positive a with
  | POSITIVE_XH  =>
    match match_positive b with
    | POSITIVE_XH  =>
      (v_HaxInt_ONE,v_HaxInt_ZERO)
    | POSITIVE_XO q | POSITIVE_XI q =>
      (v_HaxInt_ZERO,v_HaxInt_ONE)
    end
  | POSITIVE_XO a_ =>
    let '(q,r) := haxint_divmod__divmod_binary a_ (f_clone b) : t_HaxInt_t × t_HaxInt_t in
    let r_ := haxint_double r : t_HaxInt_t in
    if haxint_le (positive_to_int (f_clone b)) (f_clone r_)
    then (positive_to_int (haxint_succ_double q),haxint_sub r_ (positive_to_int b))
    else (haxint_double q,r_)
  | POSITIVE_XI a_ =>
    let '(q,r) := haxint_divmod__divmod_binary a_ (f_clone b) : t_HaxInt_t × t_HaxInt_t in
    let r_ := positive_to_int (haxint_succ_double r) : t_HaxInt_t in
    if haxint_le (positive_to_int (f_clone b)) (f_clone r_)
    then (positive_to_int (haxint_succ_double q),haxint_sub r_ (positive_to_int b))
    else (haxint_double q,r_)
  end.

Definition haxint_divmod (a : t_HaxInt_t) (b : t_HaxInt_t) : t_HaxInt_t × t_HaxInt_t :=
  match match_pos a with
  | POS_ZERO  =>
    (v_HaxInt_ZERO,v_HaxInt_ZERO)
  | POS_POS p =>
    match match_pos b with
    | POS_ZERO  =>
      (v_HaxInt_ZERO,positive_to_int p)
    | POS_POS q =>
      haxint_divmod__divmod_binary p q
    end
  end.

Definition haxint_div (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  let '(q,_) := haxint_divmod lhs rhs : t_HaxInt_t × t_HaxInt_t in
  q.

Definition haxint_mul (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  match match_pos lhs with
  | POS_ZERO  =>
    v_HaxInt_ZERO
  | POS_POS p =>
    match match_pos rhs with
    | POS_ZERO  =>
      v_HaxInt_ZERO
    | POS_POS q =>
      positive_to_int (positive_mul p q)
    end
  end.

Definition haxint_rem (lhs : t_HaxInt_t) (rhs : t_HaxInt_t) : t_HaxInt_t :=
  let '(_,r) := haxint_divmod lhs rhs : t_HaxInt_t × t_HaxInt_t in
  r.

Definition haxint_sub__sub_binary (lhs : t_Positive_t) (rhs : t_Positive_t) : t_HaxInt_t :=
  match match_positive lhs with
  | POSITIVE_XH  =>
    v_HaxInt_ZERO
  | POSITIVE_XO p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      positive_to_int (positive_pred_double p)
    | POSITIVE_XO q =>
      haxint_sub__double_mask (haxint_sub__sub_binary p q)
    | POSITIVE_XI q =>
      haxint_sub__succ_double_mask (haxint_sub__sub_carry p q)
    end
  | POSITIVE_XI p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      positive_to_int (xO p)
    | POSITIVE_XO q =>
      haxint_sub__succ_double_mask (haxint_sub__sub_binary p q)
    | POSITIVE_XI q =>
      haxint_sub__double_mask (haxint_sub__sub_binary p q)
    end
  end.

Definition haxint_sub__sub_carry (lhs : t_Positive_t) (rhs : t_Positive_t) : t_HaxInt_t :=
  match match_positive lhs with
  | POSITIVE_XH  =>
    v_HaxInt_ZERO
  | POSITIVE_XO p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      haxint_sub__double_pred_mask p
    | POSITIVE_XO q =>
      haxint_sub__succ_double_mask (haxint_sub__sub_carry p q)
    | POSITIVE_XI q =>
      haxint_sub__double_mask (haxint_sub__sub_carry p q)
    end
  | POSITIVE_XI p =>
    match match_positive rhs with
    | POSITIVE_XH  =>
      positive_to_int (positive_pred_double p)
    | POSITIVE_XO q =>
      haxint_sub__double_mask (haxint_sub__sub_binary p q)
    | POSITIVE_XI q =>
      haxint_sub__succ_double_mask (haxint_sub__sub_carry p q)
    end
  end.
