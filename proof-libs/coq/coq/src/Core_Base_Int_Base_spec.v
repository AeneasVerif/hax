(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import String.

From Core Require Import Core_Base_Int.
Export Core_Base_Int.

From Core Require Import Core_Clone (t_Clone).
Export Core_Clone (t_Clone).
(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import String.

From Core Require Import Core_Base_Int.
Export Core_Base_Int.

From Core Require Import Core_Clone (t_Clone).
Export Core_Clone (t_Clone).

Definition impl_9__ONE : t_HaxInt := 1%N.

Definition impl_9__ZERO : t_HaxInt := 0%N.

Definition v_BITS_128_ : t_HaxInt := 128%N.

Definition v_BITS_16_ : t_HaxInt := 16%N.

Definition v_BITS_32_ : t_HaxInt := 32%N.

Definition v_BITS_64_ : t_HaxInt := 64%N.

Definition v_BITS_8_ : t_HaxInt := 8%N.

Definition v_WORDSIZE_128_ : t_HaxInt := N.pow 2 128.

Definition v_WORDSIZE_128_SUB_1_ : t_HaxInt := (N.pow 2 128 - 1)%N.

Definition v_WORDSIZE_16_ : t_HaxInt := N.pow 2 16.

Definition v_WORDSIZE_16_SUB_1_ : t_HaxInt := (N.pow 2 16 - 1)%N.

Definition v_WORDSIZE_32_ : t_HaxInt := N.pow 2 32.

Definition v_WORDSIZE_32_SUB_1_ : t_HaxInt := (N.pow 2 32 - 1)%N.

Definition v_WORDSIZE_64_ : t_HaxInt := N.pow 2 64.

Definition v_WORDSIZE_64_SUB_1_ : t_HaxInt := (N.pow 2 64 - 1)%N.

Definition v_WORDSIZE_8_ : t_HaxInt := N.pow 2 8.

Definition v_WORDSIZE_8_SUB_1_ : t_HaxInt := (N.pow 2 8 - 1)%N.

Instance t_Clone_599065907 : t_Clone (t_HaxInt) :=
  {
    t_Clone_f_clone := fun (self : t_HaxInt) => self;
  }.

Definition impl_7__div2 (self : t_HaxInt) : t_HaxInt := N.div self 2.

Definition impl_9__is_zero (self : t_HaxInt) : bool := match self with | N0 => true | _ => false end.

Definition impl_9__pred (self : t_HaxInt) `{negb (impl_9__is_zero (self)) = true} : t_HaxInt :=
  N.pred self.

Definition impl_9__succ (self : t_HaxInt) : t_HaxInt :=
  N.succ self.

Instance t_Clone_793353639 : t_Clone (t_Positive) :=
  {
    t_Clone_f_clone := fun (self : t_Positive) =>
      self;
  }.

Instance t_Clone_620939287 : t_Clone (t_Unary) :=
  {
    t_Clone_f_clone := fun (self : t_Unary) =>
      self;
  }.

Definition impl_4__from_int (x : t_HaxInt) : t_Positive :=
  match x with | N0 => xH | Npos p => p end.

Definition impl_4__to_int (self : t_Positive) : t_HaxInt :=
  Npos self.

Definition impl_5__from_int (x : t_HaxInt) : t_Unary :=
  N.to_nat x.

Definition impl_5__to_int (self : t_Unary) : t_HaxInt :=
  N.of_nat self.

Definition impl_6__match_unary (self : t_Unary) : t_UNARY :=
  self.

Definition impl_8__is_xH (self : t_Positive) : bool :=
  match self with xH => true | _ => false end.

Definition impl_8__is_xI (self : t_Positive) : bool :=
  match self with xI _ => true | _ => false end.

Definition impl_8__is_xO (self : t_Positive) : bool :=
  match self with xO _ => true | _ => false end.

Definition impl_8__match_positive (self : t_Positive) : t_POSITIVE :=
  self.

Definition impl_8__xH : t_Positive :=
  xH.

Definition impl_8__xI (self : t_Positive) : t_Positive :=
  xI self.

Definition impl_8__xO (self : t_Positive) : t_Positive :=
  xO self.

Definition impl_9__match_pos (self : t_HaxInt) : t_POS :=
  if
    impl_9__is_zero ((self))
  then
    t_POS_POS_ZERO
  else
    t_POS_POS_POS (impl_4__from_int (self)).
