(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.

(* NotImplementedYet *)

From Coverage Require Import Std_Fmt (t_Display).
Export Std_Fmt (t_Display).

Definition length `{v_T : Type} `{t_Sized (v_T)} (xs : t_Slice v_T) : t_usize :=
  impl__len (xs).

Definition swap `{v_T : Type} `{t_Sized (v_T)} `{t_Copy (v_T)} (xs : t_Slice v_T) (i : t_usize) (j : t_usize) : t_Slice v_T :=
  let t := f_index (xs) (i) in
  let xs := update_at_usize (xs) (i) (f_index (xs) (j)) in
  let xs := update_at_usize (xs) (j) (t) in
  xs.

Definition display `{v_T : Type} `{t_Sized (v_T)} `{t_Display (v_T)} (xs : t_Slice v_T) : unit :=
  let _ := failure ("(FunctionalizeLoops) something is not implemented yet.This is discussed in issue https://github.com/hacspec/hax/issues/405.
Please upvote or comment this issue if you see this error message.
Loop without mutation"%string) ("{
 for x in (core::iter::traits::collect::f_into_iter(xs)) {
 {
 let _: tuple0 = {
 std::io::stdio::e_print(
 core::fmt::impl_2__new_v1::<
 generic_value!(todo),
 generic_value!(todo),
 >([""], [core:..."%string) in
  let _ := e_print (impl_2__new_const (["
"%string])) in
  let _ := tt in
  tt.

Definition error (_ : unit) : unit :=
  never_to_any (panic_fmt (impl_2__new_const (["error"%string]))).

Fixpoint permutate `{v_T : Type} `{t_Sized (v_T)} `{t_Copy (v_T)} `{t_Display (v_T)} (xs : t_Slice v_T) (k : t_usize) : t_Slice v_T :=
  let n := length (xs) in
  let xs := if
    f_eq (k) (n)
  then
    let _ := display (xs) in
    xs
  else
    if
      f_lt (k) (n)
    then
      fold_range (k) (n) (fun xs _ =>
        true) (xs) (fun xs i =>
        let xs := swap (xs) (i) (k) in
        let xs := permutate (xs) (f_add (k) (1)) in
        let xs := swap (xs) (i) (k) in
        xs)
    else
      let _ := error (tt) in
      xs in
  xs.

Definition permutations `{v_T : Type} `{t_Sized (v_T)} `{t_Copy (v_T)} `{t_Display (v_T)} (xs : t_Slice v_T) : unit :=
  let ys := f_to_owned (xs) in
  let ys := permutate (ys) (0) in
  tt.

Definition main (_ : unit) : unit :=
  let _ := permutations (unsize (["a"%char; "b"%char; "c"%char])) in
  tt.
