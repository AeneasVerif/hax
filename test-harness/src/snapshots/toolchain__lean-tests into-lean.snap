---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false



def FORTYTWO : USize := 42
def MINUS_FORTYTWO : ISize := -42
def returns42 (_ : hax_Tuple0) : Result USize := do FORTYTWO

def add_two_numbers (x : USize) (y : USize) : Result USize := do (← x +? y)

def letBinding (x : USize) (y : USize) : Result USize := do
  let (useless : hax_Tuple0) ← pure ();
  let (result1 : USize) ← pure (← x +? y);
  let (result2 : USize) ← pure (← result1 +? 2);
  (← result2 +? 1)

def closure (_ : hax_Tuple0) : Result Int32 := do
  let (x : Int32) ← pure 41;
  let (f1 : Int32 -> Result Int32) ← pure (fun (y : Int32) => do (← y +? x));
  let (f2 : Int32 -> Int32 -> Result Int32) ← pure
    (fun (y : Int32) (z : Int32) => do (← (← y +? x) +? z));
  (← (← ops_function_Fn_call f1 (.Tuple1 1)) +? (← ops_function_Fn_call
  f2
    (.Tuple2 2 3)))


@[spec]
def test_before_verbatime_single_line (x : UInt8) : Result UInt8 := do 42



def multiline : Unit := ()

def test_before_verbatim_multi_line (x : UInt8) : Result UInt8 := do 32

def binop_resugarings (x : UInt32) : Result UInt32 := do
  (← (← (← x +? 1) -? (← (← (← 2 *? 3) %? 4) /? 5)) >>>? 1)

inductive WebEvent : Type
| PageLoad  : WebEvent
| PageUnload  : WebEvent
| KeyPress  : Char -> WebEvent
| Paste  : USize -> WebEvent
| Click (x : Int64) (y : Int64) : WebEvent


def inspect (event : WebEvent) : Result hax_Tuple0 := do
  match event with
    | (.PageLoad : WebEvent) | (.PageUnload : WebEvent) => ()
    | (.KeyPress (c : Char)) => ()
    | (.Paste (s : USize)) => ()
    | (.Click (x := (x : Int64)) (y := (y : Int64))) => ()

def main_enum (_ : hax_Tuple0) : Result hax_Tuple0 := do
  let (pressed : WebEvent) ← pure (.KeyPress 'x');
  let (pasted : WebEvent) ← pure (.Paste 56);
  let (click : WebEvent) ← pure (.Click (x := 20) (y := 80));
  let (load : WebEvent) ← pure .PageLoad;
  let (unload : WebEvent) ← pure .PageUnload;
  let (_ : hax_Tuple0) ← pure (← inspect pressed);
  let (_ : hax_Tuple0) ← pure (← inspect pasted);
  let (_ : hax_Tuple0) ← pure (← inspect click);
  let (_ : hax_Tuple0) ← pure (← inspect load);
  let (_ : hax_Tuple0) ← pure (← inspect unload);
  ()
'''
