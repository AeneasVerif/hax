---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: lean
  info:
    name: lean-tests
    manifest: lean-tests/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = 'Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs'

[stdout]
diagnostics = []

[stdout.files]
"lean_tests.lean" = '''

-- Experimental lean backend for Hax
-- The Hax prelude library can be found in hax/proof-libs/lean
import Hax
import Std.Tactic.Do
import Std.Do.Triple
import Std.Tactic.Do.Syntax
open Std.Do
open Std.Tactic

set_option mvcgen.warning false
set_option linter.unusedVariables false

def FORTYTWO : USize := 42

def MINUS_FORTYTWO : ISize := -42

def returns42 (_ : hax.Tuple0) : Result USize := do FORTYTWO

def add_two_numbers (x : USize) (y : USize) : Result USize := do (← x +? y)

def letBinding (x : USize) (y : USize) : Result USize := do
  let (useless : hax.Tuple0) ← pure hax.Tuple0.mk;
  let (result1 : USize) ← pure (← x +? y);
  let (result2 : USize) ← pure (← result1 +? 2);
  (← result2 +? 1)

def closure (_ : hax.Tuple0) : Result Int32 := do
  let (x : Int32) ← pure 41;
  let (f1 : Int32 -> Result Int32) ← pure (fun (y : Int32) => do (← y +? x));
  let (f2 : Int32 -> Int32 -> Result Int32) ← pure
    (fun (y : Int32) (z : Int32) => do (← (← y +? x) +? z));
  (← (← ops.function.Fn.call f1 (hax.Tuple1.mk 1)) +? (← ops.function.Fn.call
  f2
    (hax.Tuple2.mk 2 3)))

@[spec]

def test_before_verbatime_single_line (x : UInt8) : Result UInt8 := do 42


def multiline : Unit := ()


def test_before_verbatim_multi_line (x : UInt8) : Result UInt8 := do 32

def binop_resugarings (x : UInt32) : Result UInt32 := do
  (← (← (← x +? 1) -? (← (← (← 2 *? 3) %? 4) /? 5)) >>>? 1)

inductive WebEvent : Type
| PageLoad  : WebEvent
| PageUnload  : WebEvent
| KeyPress  : Char -> WebEvent
| Paste  : USize -> USize -> WebEvent
| Click (_x : Int64) (_y : Int64) : WebEvent


def inspect (event : WebEvent) : Result hax.Tuple0 := do
  match event with
    | (.PageLoad : WebEvent) | (.PageUnload : WebEvent) => hax.Tuple0.mk
    | (.KeyPress (c : Char)) => hax.Tuple0.mk
    | (.Paste (s1 : USize) (s2 : USize)) => hax.Tuple0.mk
    | (.Click (_x := (other_name_for_x : Int64)) (_y := (y : Int64))) =>
    hax.Tuple0.mk

def main_enum (_ : hax.Tuple0) : Result hax.Tuple0 := do
  let (pressed : WebEvent) ← pure (WebEvent.KeyPress 'x');
  let (pasted : WebEvent) ← pure (WebEvent.Paste 56 42);
  let (click : WebEvent) ← pure (WebEvent.Click (_x := 20) (_y := 80));
  let (load : WebEvent) ← pure WebEvent.PageLoad;
  let (unload : WebEvent) ← pure WebEvent.PageUnload;
  let (_ : hax.Tuple0) ← pure (← inspect pressed);
  let (_ : hax.Tuple0) ← pure (← inspect pasted);
  let (_ : hax.Tuple0) ← pure (← inspect click);
  let (_ : hax.Tuple0) ← pure (← inspect load);
  let (_ : hax.Tuple0) ← pure (← inspect unload);
  hax.Tuple0.mk

structure T0 where


structure T1 A where
  _0 : A

structure T2 A B where
  _0 : A
  _1 : B

def f_manual_tuples (_ : hax.Tuple0) : Result hax.Tuple0 := do
  let (t0 : T0) ← pure T0.mk;
  let (t1 : (T1 Int32)) ← pure (T1.mk 32);
  let (t2 : (T2 Int32 Int32)) ← pure (T2.mk 1 2);
  hax.Tuple0.mk

def main_tuples (_ : hax.Tuple0) : Result hax.Tuple0 := do
  let ((t0 : hax.Tuple0) : hax.Tuple0) ← pure hax.Tuple0.mk;
  let ((t1 : (hax.Tuple1 USize)) : (hax.Tuple1 USize)) ← pure
    (hax.Tuple1.mk 42);
  let ((t2 : (hax.Tuple2 USize ISize)) : (hax.Tuple2 USize ISize)) ← pure
    (hax.Tuple2.mk 42 41);
  let ((t3 : (hax.Tuple3 UInt32 UInt64 UInt8)) : (hax.Tuple3 UInt32 UInt64
  UInt8)) ← pure (hax.Tuple3.mk 1 2 3);
  hax.Tuple0

structure Person where
  _name : string.String
  _age : UInt8

structure MyUnit where


structure Pair where
  _0 : Int32
  _1 : Int64

structure Point where
  _x : Int64
  _y : Int64

structure Rectangle where
  _top_left : Point
  _bottom_right : Point

def main_structs (_ : hax.Tuple0) : Result hax.Tuple0 := do
  let (name : string.String) ← pure (← convert.From.from "Peter");
  let (age : UInt8) ← pure 27;
  let (peter : Person) ← pure (Person.mk (_name := name) (_age := age));
  let ((point : Point) : Point) ← pure (Point.mk (_x := 5) (_y := 0));
  let ((another_point : Point) : Point) ← pure (Point.mk (_x := 10) (_y := 0));
  let (_rectangle : Rectangle) ← pure
    (Rectangle.mk
    (_top_left := (Point.mk (_x := 0) (_y := 1))) (_bottom_right := point));
  let (_unit : MyUnit) ← pure MyUnit.mk;
  let (pair : Pair) ← pure (Pair.mk 1 0);
  hax.Tuple0'''
