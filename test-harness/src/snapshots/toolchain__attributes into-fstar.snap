---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: fstar
  info:
    name: attributes
    manifest: attributes/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: false
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0

[stdout]
diagnostics = []

[stdout.files]
"Attributes.Newtype_pattern.fst" = '''
module Attributes.Newtype_pattern
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

let v_MAX: usize = sz 10

type t_SafeIndex = { f_i:f_i: usize{f_i <. v_MAX} }

let impl__SafeIndex__as_usize (self: t_SafeIndex) : usize = self.f_i

let impl__SafeIndex__new (i: usize) : Core.Option.t_Option t_SafeIndex =
  if i <. v_MAX
  then Core.Option.Option_Some ({ f_i = i } <: t_SafeIndex) <: Core.Option.t_Option t_SafeIndex
  else Core.Option.Option_None <: Core.Option.t_Option t_SafeIndex

[@@ FStar.Tactics.Typeclasses.tcinstance]
let impl_1 (#v_T: Type) (#[FStar.Tactics.Typeclasses.tcresolve ()] i0: Core.Marker.t_Sized v_T)
    : Core.Ops.Index.t_Index (t_Array v_T (sz 10)) t_SafeIndex =
  {
    f_Output = v_T;
    f_index_pre = (fun (self: t_Array v_T (sz 10)) (index: t_SafeIndex) -> true);
    f_index_post = (fun (self: t_Array v_T (sz 10)) (index: t_SafeIndex) (out: v_T) -> true out);
    f_index = fun (self: t_Array v_T (sz 10)) (index: t_SafeIndex) -> self.[ index.f_i ]
  }
'''
"Attributes.Refined_indexes.fst" = '''
module Attributes.Refined_indexes
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

let v_MAX: usize = sz 10

type t_MyArray = | MyArray : t_Array u8 (sz 10) -> t_MyArray

[@@ FStar.Tactics.Typeclasses.tcinstance]
let impl: Core.Ops.Index.t_Index t_MyArray usize =
  {
    f_Output = u8;
    f_index_pre = (fun (self: t_MyArray) (index: usize) -> index <. v_MAX);
    f_index_post = (fun (self: t_MyArray) (index: usize) (out: u8) -> true out);
    f_index = fun (self: t_MyArray) (index: usize) -> self.[ index ]
  }
'''
"Attributes.fst" = '''
module Attributes
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

let add3_lemma (x: u32)
    : Lemma Prims.l_True
      (ensures
        x <=. 10ul || x >=. (u32_max /! 3ul <: u32) || (add3 x x x <: u32) =. (x *! 3ul <: u32)) =
  ()

let u32_max: u32 = 90000ul

let add3 (x y z: u32)
    : Prims.Pure u32
      (requires x >. 10ul && y >. 10ul && z >. 10ul && ((x +! y <: u32) +! z <: u32) <. u32_max)
      (ensures
        fun result ->
          let result:u32 = result in
          Hax_lib.implies true
            (fun temp_0_ ->
                let _:Prims.unit = temp_0_ in
                result >. 32ul <: bool)) = (x +! y <: u32) +! z

type t_Foo = {
  f_x:u32;
  f_y:f_y: u32{f_y >. 3ul};
  f_z:f_z: u32{((f_y +! f_x <: u32) +! f_z <: u32) >. 3ul}
}
'''
