---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: fstar
  info:
    name: traits
    manifest: traits/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 0
stderr = '''
Compiling traits v0.1.0 (WORKSPACE_ROOT/traits)
disabled backtrace
warning[HaxFront]: Hax frontend found a projected type with escaping bound vars. Please report https://github.com/hacspec/hax/issues/495
                   
                   Context:
                    - alias_ty: AliasTy {
                       substs: [
                           P,
                           (&u8,),
                       ],
                       def_id: DefId(2:2933 ~ core[7e13]::ops::function::FnOnce::Output),
                   }
                    - alias_kind: Projection
                    - trait_ref: <P as std::ops::FnOnce<(&u8,)>>
                    - trait_ref_and_substs: (
                       <P as std::ops::FnOnce<(&u8,)>>,
                       [],
                   )
                    - rebased_substs: [
                       P,
                       (&u8,),
                       (&u8,),
                   ]
                    - norm_rebased_substs: Ok(
                       <P as std::ops::FnOnce<(&u8,)>>,
                   )
                    - norm_substs: Ok(
                       <P as std::ops::FnOnce<(&u8,)>>,
                   )
                    - early_binder_substs: Ok(
                       <P as std::ops::FnOnce<(&u8,)>>,
                   )
                    - early_binder_rebased_substs: Ok(
                       <P as std::ops::FnOnce<(&u8,)>>,
                   )
   --> traits/src/lib.rs:107:13
    |
107 |             impl<P: FnMut(&u8) -> bool> Trait for P {}
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: ⚠️ This is a bug in Hax's frontend.
            Please report this error to https://github.com/hacspec/hax/issues with some context (e.g. the current crate)!

disabled backtrace
disabled backtrace
disabled backtrace
disabled backtrace
disabled backtrace
disabled backtrace
disabled backtrace
disabled backtrace
warning[HaxFront]: Hax frontend found a projected type with escaping bound vars. Please report https://github.com/hacspec/hax/issues/495
                   
                   Context:
                    - alias_ty: AliasTy {
                       substs: [
                           P,
                           (&<I as std::iter::Iterator>::Item,),
                       ],
                       def_id: DefId(2:2933 ~ core[7e13]::ops::function::FnOnce::Output),
                   }
                    - alias_kind: Projection
                    - trait_ref: <P as std::ops::FnOnce<(&<I as std::iter::Iterator>::Item,)>>
                    - trait_ref_and_substs: (
                       <P as std::ops::FnOnce<(&<I as std::iter::Iterator>::Item,)>>,
                       [],
                   )
                    - rebased_substs: [
                       P,
                       (&<I as std::iter::Iterator>::Item,),
                       (&<I as std::iter::Iterator>::Item,),
                   ]
                    - norm_rebased_substs: Err(
                       Type(
                           (&<P as std::iter::Iterator>::Item,),
                       ),
                   )
                    - norm_substs: Err(
                       Type(
                           (&<P as std::iter::Iterator>::Item,),
                       ),
                   )
                    - early_binder_substs: Ok(
                       <(&<I as std::iter::Iterator>::Item,) as std::ops::FnOnce<(&<P as std::iter::Iterator>::Item,)>>,
                   )
                    - early_binder_rebased_substs: Ok(
                       <(&<I as std::iter::Iterator>::Item,) as std::ops::FnOnce<(&<P as std::iter::Iterator>::Item,)>>,
                   )
  --> /nix/store/bbq0z3kg0b7hb3n7agk20r7hg3alf4kb-rust-default-1.72.0-nightly-2023-06-28/lib/rustlib/src/rust/library/core/src/iter/adapters/filter.rs:51:1
   |
51 | impl<I: Iterator, P> Iterator for Filter<I, P>
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: ⚠️ This is a bug in Hax's frontend.
           Please report this error to https://github.com/hacspec/hax/issues with some context (e.g. the current crate)!

disabled backtrace
disabled backtrace
disabled backtrace
warning: `traits` (lib) generated 2 warnings
    Finished dev [unoptimized + debuginfo] target(s) in XXs'''

[stdout]
diagnostics = []

[stdout.files]
"Traits.For_clauses.Issue_495_.Minimized_3_.fst" = '''
module Traits.For_clauses.Issue_495_.Minimized_3_
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

class t_Trait (v_Self: Type0) = { __marker_trait_t_Trait:Prims.unit }

[@@ FStar.Tactics.Typeclasses.tcinstance]
let impl
      (#v_P: Type0)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] i0: Core.Ops.Function.t_FnMut v_P u8)
    : t_Trait v_P = { __marker_trait = () }
'''
"Traits.For_clauses.Issue_495_.fst" = '''
module Traits.For_clauses.Issue_495_
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

let minimized_1_ (list: Alloc.Vec.t_Vec u8 Alloc.Alloc.t_Global)
    : Alloc.Vec.t_Vec u8 Alloc.Alloc.t_Global =
  Core.Iter.Traits.Iterator.f_collect (Core.Iter.Traits.Iterator.f_filter ({
            Core.Ops.Range.f_start = 0uy;
            Core.Ops.Range.f_end = 5uy
          }
          <:
          Core.Ops.Range.t_Range u8)
        (fun temp_0_ ->
            let _:u8 = temp_0_ in
            true)
      <:
      Core.Iter.Adapters.Filter.t_Filter (Core.Ops.Range.t_Range u8) (u8 -> bool))

let minimized_2_ (it: Core.Iter.Adapters.Filter.t_Filter (Core.Ops.Range.t_Range u8) (u8 -> bool))
    : Prims.unit =
  let (v__indices: Alloc.Vec.t_Vec u8 Alloc.Alloc.t_Global):Alloc.Vec.t_Vec u8 Alloc.Alloc.t_Global
  =
    Core.Iter.Traits.Iterator.f_collect it
  in
  ()

let original_function_from_495_ (list: Alloc.Vec.t_Vec u8 Alloc.Alloc.t_Global) : Prims.unit =
  let (v__indices: Alloc.Vec.t_Vec u8 Alloc.Alloc.t_Global):Alloc.Vec.t_Vec u8 Alloc.Alloc.t_Global
  =
    Core.Iter.Traits.Iterator.f_collect (Core.Iter.Traits.Iterator.f_filter ({
              Core.Ops.Range.f_start = 0uy;
              Core.Ops.Range.f_end = 5uy
            }
            <:
            Core.Ops.Range.t_Range u8)
          (fun i ->
              let i:u8 = i in
              let _, out:(Core.Slice.Iter.t_Iter u8 & bool) =
                Core.Iter.Traits.Iterator.f_any (Core.Slice.impl__iter (Core.Ops.Deref.f_deref list
                        <:
                        t_Slice u8)
                    <:
                    Core.Slice.Iter.t_Iter u8)
                  (fun n ->
                      let n:u8 = n in
                      n =. i <: bool)
              in
              out)
        <:
        Core.Iter.Adapters.Filter.t_Filter (Core.Ops.Range.t_Range u8) (u8 -> bool))
  in
  ()
'''
"Traits.For_clauses.fst" = '''
module Traits.For_clauses
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

class t_Foo (v_Self: Type0) (v_T: Type0) = {
  f_to_t_pre:v_Self -> bool;
  f_to_t_post:v_Self -> v_T -> bool;
  f_to_t:x0: v_Self -> Prims.Pure v_T (f_to_t_pre x0) (fun result -> f_to_t_post x0 result)
}

let v__f (#v_X: Type0) (#[FStar.Tactics.Typeclasses.tcresolve ()] i1: t_Foo v_X u8) (x: v_X)
    : Prims.unit =
  let _:u8 = f_to_t x in
  ()
'''
"Traits.fst" = '''
module Traits
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core
open FStar.Mul

class t_Bar (v_Self: Type0) = {
  f_bar_pre:v_Self -> bool;
  f_bar_post:v_Self -> Prims.unit -> bool;
  f_bar:x0: v_Self -> Prims.Pure Prims.unit (f_bar_pre x0) (fun result -> f_bar_post x0 result)
}

let impl_2__method (#v_T: Type0) (#[FStar.Tactics.Typeclasses.tcresolve ()] i1: t_Bar v_T) (x: v_T)
    : Prims.unit = f_bar x

type t_Error = | Error_Fail : t_Error

let impl__Error__for_application_callback (_: Prims.unit) :  Prims.unit -> t_Error =
  fun temp_0_ ->
    let _:Prims.unit = temp_0_ in
    Error_Fail <: t_Error

let t_Error_cast_to_repr (x: t_Error) : isize = match x with | Error_Fail  -> isz 0

class t_Lang (v_Self: Type0) = {
  f_Var:Type0;
  f_s_pre:v_Self -> i32 -> bool;
  f_s_post:v_Self -> i32 -> (v_Self & f_Var) -> bool;
  f_s:x0: v_Self -> x1: i32
    -> Prims.Pure (v_Self & f_Var) (f_s_pre x0 x1) (fun result -> f_s_post x0 x1 result)
}

class t_SuperTrait (v_Self: Type0) = {
  [@@@ FStar.Tactics.Typeclasses.no_method]_super_10391689928755043351:Core.Clone.t_Clone v_Self;
  f_function_of_super_trait_pre:v_Self -> bool;
  f_function_of_super_trait_post:v_Self -> u32 -> bool;
  f_function_of_super_trait:x0: v_Self
    -> Prims.Pure u32
        (f_function_of_super_trait_pre x0)
        (fun result -> f_function_of_super_trait_post x0 result)
}

[@@ FStar.Tactics.Typeclasses.tcinstance]
let impl_SuperTrait_for_i32: t_SuperTrait i32 =
  {
    _super_10391689928755043351 = FStar.Tactics.Typeclasses.solve;
    f_function_of_super_trait_pre = (fun (self: i32) -> true);
    f_function_of_super_trait_post = (fun (self: i32) (out: u32) -> true);
    f_function_of_super_trait = fun (self: i32) -> cast (Core.Num.impl__i32__abs self <: i32) <: u32
  }

class t_Foo (v_Self: Type0) = {
  f_AssocType:Type0;
  f_AssocType_1566547207180513319:t_SuperTrait f_AssocType;
  f_AssocType_18427724250319916167:Core.Clone.t_Clone f_AssocType;
  f_N:usize;
  f_assoc_f_pre:Prims.unit -> bool;
  f_assoc_f_post:Prims.unit -> Prims.unit -> bool;
  f_assoc_f:x0: Prims.unit
    -> Prims.Pure Prims.unit (f_assoc_f_pre x0) (fun result -> f_assoc_f_post x0 result);
  f_method_f_pre:v_Self -> bool;
  f_method_f_post:v_Self -> Prims.unit -> bool;
  f_method_f:x0: v_Self
    -> Prims.Pure Prims.unit (f_method_f_pre x0) (fun result -> f_method_f_post x0 result);
  f_assoc_type_pre:{| i3: Core.Marker.t_Copy f_AssocType |} -> f_AssocType -> bool;
  f_assoc_type_post:{| i3: Core.Marker.t_Copy f_AssocType |} -> f_AssocType -> Prims.unit -> bool;
  f_assoc_type:{| i3: Core.Marker.t_Copy f_AssocType |} -> x0: f_AssocType
    -> Prims.Pure Prims.unit (f_assoc_type_pre i3 x0) (fun result -> f_assoc_type_post i3 x0 result)
}

let closure_impl_expr
      (#v_I: Type0)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] i1: Core.Iter.Traits.Iterator.t_Iterator v_I)
      (it: v_I)
    : Alloc.Vec.t_Vec Prims.unit Alloc.Alloc.t_Global =
  Core.Iter.Traits.Iterator.f_collect (Core.Iter.Traits.Iterator.f_map it (fun x -> x)
      <:
      Core.Iter.Adapters.Map.t_Map v_I (Prims.unit -> Prims.unit))

let closure_impl_expr_fngen
      (#v_I #v_F: Type0)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] i2: Core.Iter.Traits.Iterator.t_Iterator v_I)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] i3: Core.Ops.Function.t_FnMut v_F Prims.unit)
      (it: v_I)
      (f: v_F)
    : Alloc.Vec.t_Vec Prims.unit Alloc.Alloc.t_Global =
  Core.Iter.Traits.Iterator.f_collect (Core.Iter.Traits.Iterator.f_map it f
      <:
      Core.Iter.Adapters.Map.t_Map v_I v_F)

let f (#v_T: Type0) (#[FStar.Tactics.Typeclasses.tcresolve ()] i1: t_Foo v_T) (x: v_T) : Prims.unit =
  let _:Prims.unit = f_assoc_f () in
  f_method_f x

let g (#v_T: Type0) (#[FStar.Tactics.Typeclasses.tcresolve ()] i1: t_Foo v_T) (x: i1.f_AssocType)
    : u32 = f_function_of_super_trait x

[@@ FStar.Tactics.Typeclasses.tcinstance]
let impl_Foo_for_tuple_: t_Foo Prims.unit =
  {
    f_AssocType = i32;
    f_AssocType_1566547207180513319 = FStar.Tactics.Typeclasses.solve;
    f_N = sz 32;
    f_assoc_f_pre = (fun (_: Prims.unit) -> true);
    f_assoc_f_post = (fun (_: Prims.unit) (out: Prims.unit) -> true);
    f_assoc_f = (fun (_: Prims.unit) -> () <: Prims.unit);
    f_method_f_pre = (fun (self: Prims.unit) -> true);
    f_method_f_post = (fun (self: Prims.unit) (out: Prims.unit) -> true);
    f_method_f = (fun (self: Prims.unit) -> f_assoc_f ());
    f_assoc_type_pre = (fun (_: i32) -> true);
    f_assoc_type_post = (fun (_: i32) (out: Prims.unit) -> true);
    f_assoc_type = fun (_: i32) -> ()
  }

type t_Struct = | Struct : t_Struct
'''
