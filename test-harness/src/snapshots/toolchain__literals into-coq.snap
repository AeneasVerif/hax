---
source: test-harness/src/harness.rs
expression: snapshot
info:
  kind:
    Translate:
      backend: coq
  info:
    name: literals
    manifest: literals/Cargo.toml
    description: ~
  spec:
    optional: false
    broken: false
    issue_id: ~
    positive: true
    snapshot:
      stderr: true
      stdout: true
    include_flag: ~
    backend_options: ~
---
exit = 1
stderr = """
Finished `dev` profile [unoptimized + debuginfo] target(s) in XXs
\u001B[1m\u001B[91merror\u001B[0m: \u001B[1m[HAX0001] (AST import) something is not implemented yet.This is discussed in issue https://github.com/hacspec/hax/issues/156.
Please upvote or comment this issue if you see this error message.
Sorry, Hax does not support declare-first let bindings (see https://doc.rust-lang.org/rust-by-example/variable_bindings/declare.html) for now.\u001B[0m
  \u001B[1m\u001B[94m-->\u001B[0m literals/src/lib.rs:43:21
\u001B[1m\u001B[94m   |\u001B[0m
\u001B[1m\u001B[94m43 |\u001B[0m #[derive(PartialEq, Eq)]
\u001B[1m\u001B[94m   |\u001B[0m\u001B[1m\u001B[91m                     ^^\u001B[0m
\u001B[1m\u001B[94m   |\u001B[0m"""
[[stdout.diagnostics]]
message = '''
(AST import) something is not implemented yet.This is discussed in issue https://github.com/hacspec/hax/issues/156.
Please upvote or comment this issue if you see this error message.
Sorry, Hax does not support declare-first let bindings (see https://doc.rust-lang.org/rust-by-example/variable_bindings/declare.html) for now.'''
spans = ['Span { lo: Loc { line: 43, col: 20 }, hi: Loc { line: 43, col: 22 }, filename: Real(LocalPath("literals/src/lib.rs")), rust_span_data: None }']

[stdout.files]
"Literals.v" = '''
(* File automatically generated by Hacspec *)
From Coq Require Import ZArith.
Require Import List.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.
Require Import Ascii.
Require Import String.
Require Import Coq.Floats.Floats.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.
From Core Require Import Core.



(* NotImplementedYet *)



Definition math_integers (x : t_Int) `{andb (f_gt (x) (impl_Int__e_unsafe_from_str (("0"%string : string)))) (f_lt (x) (impl_Int__e_unsafe_from_str (("16"%string : string)))) = true} : t_u8 :=
  let _ : t_Int := f_lift ((3 : t_usize)) in
  let e_neg_dec := impl_Int__e_unsafe_from_str (("-340282366920938463463374607431768211455000"%string : string)) in
  let e_pos_dec := impl_Int__e_unsafe_from_str (("340282366920938463463374607431768211455000"%string : string)) in
  let e_neg_hex := impl_Int__e_unsafe_from_str (("-340282366920938463463374607431768211455000"%string : string)) in
  let e_pos_hex := impl_Int__e_unsafe_from_str (("340282366920938463463374607431768211455000"%string : string)) in
  let e_neg_octal := impl_Int__e_unsafe_from_str (("-340282366920938463463374607431768211455000"%string : string)) in
  let e_pos_octal := impl_Int__e_unsafe_from_str (("340282366920938463463374607431768211455000"%string : string)) in
  let e_neg_bin := impl_Int__e_unsafe_from_str (("-340282366920938463463374607431768211455000"%string : string)) in
  let e_pos_bin := impl_Int__e_unsafe_from_str (("340282366920938463463374607431768211455000"%string : string)) in
  let _ := f_gt (impl_Int__e_unsafe_from_str (("-340282366920938463463374607431768211455000"%string : string))) (impl_Int__e_unsafe_from_str (("340282366920938463463374607431768211455000"%string : string))) in
  let _ := f_lt (x) (x) in
  let _ := f_ge (x) (x) in
  let _ := f_le (x) (x) in
  let _ := f_ne (x) (x) in
  let _ := f_eq (x) (x) in
  let _ := f_add (x) (x) in
  let _ := f_sub (x) (x) in
  let _ := f_mul (x) (x) in
  let _ := f_div (x) (x) in
  let _ : t_i16 := impl_Int__to_i16 (x) in
  let _ : t_i32 := impl_Int__to_i32 (x) in
  let _ : t_i64 := impl_Int__to_i64 (x) in
  let _ : t_i128 := impl_Int__to_i128 (x) in
  let _ : t_isize := impl_Int__to_isize (x) in
  let _ : t_u16 := impl_Int__to_u16 (x) in
  let _ : t_u32 := impl_Int__to_u32 (x) in
  let _ : t_u64 := impl_Int__to_u64 (x) in
  let _ : t_u128 := impl_Int__to_u128 (x) in
  let _ : t_usize := impl_Int__to_usize (x) in
  impl_Int__to_u8 (f_add (x) (f_mul (x) (x))).

Definition panic_with_msg '(_ : unit) : unit :=
  never_to_any (panic_fmt (impl_1__new_const ([("with msg"%string : string)]))).

Record Foo_record : Type :=
  {
    Foo_f_field : t_u8;
  }.


#[export] Instance settable_Foo_record : Settable _ :=
  settable! (Build_Foo_record) <Foo_f_field>.

Instance t_StructuralPartialEq_61223753 : t_StructuralPartialEq ((t_Foo)) :=
  {
  }.

Instance t_PartialEq_662037409 : t_PartialEq ((t_Foo)) ((t_Foo)) :=
  {
    implaabbcc_t_PartialEq_f_eq := fun  (self : t_Foo) (other : t_Foo)=>
      f_eq (f_field self) (f_field other);
  }.

Instance t_Eq_795626685 : t_Eq ((t_Foo)) :=
  {
    implaabbcc_t_Eq_f_assert_receiver_is_total_eq := fun  (self : t_Foo)=>
      failure (("(AST import) something is not implemented yet.This is discussed in issue https://github.com/hacspec/hax/issues/156.
Please upvote or comment this issue if you see this error message.
Sorry, Hax does not support declare-first let bindings (see https://doc.rust-lang.org/rust-by-example/variable_bindings/declare.html) for now."%string : string)) ((""%string : string));
  }.

Definition v_CONSTANT : t_Foo :=
  Foo ((3 : t_u8)).

Definition numeric '(_ : unit) : unit :=
  let _ : t_usize := (123 : t_usize) in
  let _ : t_isize := (-42 : t_isize) in
  let _ : t_isize := (42 : t_isize) in
  let _ : t_i32 := (-42 : t_i32) in
  let _ : t_u128 := (22222222222222222222 : t_u128) in
  tt.

Definition patterns '(_ : unit) : unit :=
  let _ := match (1 : t_u8) with
  | 2 =>
    tt
  | _ =>
    tt
  end in
  let _ := match (("hello"%string : string),((123 : t_i32),[("a"%string : string); ("b"%string : string)])) with
  | ("hello"%string,(123,e_todo)) =>
    tt
  | _ =>
    tt
  end in
  let _ := match Foo ((4 : t_u8)) with
  | Foo (3) =>
    tt
  | _ =>
    tt
  end in
  tt.

Definition casts (x8 : t_u8) (x16 : t_u16) (x32 : t_u32) (x64 : t_u64) (xs : t_usize) : unit :=
  let _ : t_u64 := f_add (f_add (f_add (f_add (cast (x8)) (cast (x16))) (cast (x32))) (x64)) (cast (xs)) in
  let _ : t_u32 := f_add (f_add (f_add (f_add (cast (x8)) (cast (x16))) (x32)) (cast (x64))) (cast (xs)) in
  let _ : t_u16 := f_add (f_add (f_add (f_add (cast (x8)) (x16)) (cast (x32))) (cast (x64))) (cast (xs)) in
  let _ : t_u8 := f_add (f_add (f_add (f_add (x8) (cast (x16))) (cast (x32))) (cast (x64))) (cast (xs)) in
  let _ : t_i64 := f_add (f_add (f_add (f_add (cast (x8)) (cast (x16))) (cast (x32))) (cast (x64))) (cast (xs)) in
  let _ : t_i32 := f_add (f_add (f_add (f_add (cast (x8)) (cast (x16))) (cast (x32))) (cast (x64))) (cast (xs)) in
  let _ : t_i16 := f_add (f_add (f_add (f_add (cast (x8)) (cast (x16))) (cast (x32))) (cast (x64))) (cast (xs)) in
  let _ : t_i8 := f_add (f_add (f_add (f_add (cast (x8)) (cast (x16))) (cast (x32))) (cast (x64))) (cast (xs)) in
  tt.

Definition empty_array '(_ : unit) : unit :=
  let _ : t_Slice t_u8 := unsize ([]) in
  tt.

Definition fn_pointer_cast '(_ : unit) : unit :=
  let f : t_u32 -> t_u32 := fun x =>
    x in
  tt.

Definition null : ascii :=
  ("\000"%char : ascii).
'''
_CoqProject = '''
-R ./ TODO
-arg -w
-arg all

Literals.v'''
